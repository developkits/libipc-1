#!/usr/bin/env ruby
#
# Copyright (c) 2015 Mark Heily <mark@heily.com>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

require 'erb'
require 'yaml'
require 'pp'

module IPC

  class Method
    attr_accessor :accepts, :returns, :name, :service

    def initialize(service, name, spec)
      @service = service
      @name = name
      @spec = spec
      @accepts = spec['accepts']
      @returns = spec['returns']
    end

    def prototype
      template = <<__EOF__
int #{@name}(
#{
  tok = ["\t/* returns */\n\t"]
  tok << @returns.map { |ent| "#{ent.values[0]} *#{ent.keys[0]}" }.join(', ')
  tok << ", "
  tok << "\n\t/* accepts */\n\t"
  tok << @accepts.map { |ent| "#{ent.values[0]} #{ent.keys[0]}" }.join(', ')
  tok.join
})
__EOF__
    template.chomp
    end

    def args_to_iovec
      count = 0
      tok = []
      tok << "iov_in[0].iov_base = \"#{name}\""
      tok << "iov_in[0].iov_len = strlen(iov_in[0].iov_base)"
      @accepts.each do |arg|
        count += 1
        ident = arg.keys[0]
        type = arg.values[0]

	case type
	when 'char *'
          tok << "iov_in[#{count}].iov_base = #{ident}"
          tok << "iov_in[#{count}].iov_len = strlen(#{ident}) + 1"
	when /\A[u]int\d+_t\z/, /(unsigned )?(long |int )?(int|long|char)/, 'float', 'double', 'long double',
             /\Astruct [A-Za-z0-9_]+\z/
          tok << "iov_in[#{count}].iov_base = &#{ident}"
          tok << "iov_in[#{count}].iov_len = sizeof(#{ident})"
	else
	  raise 'Unknown datatype; need to specify the calling convention'
	end
      end
      tok << ''
      tok.join(";\n\t")
    end

    def rets_to_iovec
      count = 0
      tok = []
      @returns.each do |arg|
        ident = arg.keys[0]
        type = arg.values[0]

	case type
	when 'char **'
	  # Lame initial attempt:
          #tok << "*#{ident} = malloc(4096);"
          #tok << "iov_out[#{count}].iov_base = *#{ident}"
          #tok << "iov_out[#{count}].iov_len = 4096"
	  raise "FIXME -- it will be possible to overflow iov_base and break everything"
	  raise "FIXME -- this will leak memory if the call fails"
	when /\A[u]int\d+_t\z/, /(unsigned )?(long |int )?(int|long|char)/, 'float', 'double', 'long double'
          tok << "iov_out[#{count}].iov_base = #{ident}"
          tok << "iov_out[#{count}].iov_len = sizeof(*#{ident})"
	else
	  raise 'Unknown datatype; need to specify the calling convention'
	end
        count += 1
      end
      tok << ''
      tok.join(";\n\t")
    end
  end

  class Service
    attr_accessor :version, :name, :domain, :methods

    def initialize(spec)
      @version = spec['version']
      @name = spec['service']
      @domain = spec['domain']
      @methods = spec['methods'].map do |name, body|
        Method.new(self, name, body)
      end
    end

    def to_c_header
      template = <<__EOF__
/* Automatically generated by ipcc(1) -- do not edit */
#ifndef #{include_guard_name}
#define #{include_guard_name}

#include <ipc.h>

#{@methods.map { |method| method.prototype }.join(";\n\n")};

#endif /* !#{include_guard_name} */
__EOF__
      ERB.new(template).result(binding)
    end

    def to_c_source
      template = <<__EOF__
/* Automatically generated by ipcc(1) -- do not edit */

#include <ipc.h>

<% @methods.each do |method| %>
<%= method.prototype  %>
{
	struct iovec iov_in[<%= method.accepts.length + 1 %>];
	struct iovec iov_out[<%= method.returns.length %>];
	int fd;

	fd = ipc_client(<%= method.service.domain %>, "<%= method.service.name %>", <%= method.service.version %>);
	if (fd < 0) { 
		return -IPC_ERROR_CONNECTION_FAILED;
	}

	<%= method.args_to_iovec.chomp %>
	if (ipc_write(fd, &iov_in, sizeof(iov_in) < sizeof(iov_in)) {
		return -IPC_ERROR_REQUEST_FAILED;
	}

	<%= method.rets_to_iovec.chomp %>
	if (ipc_read(fd, &iov_out, sizeof(iov_out) < sizeof(iov_out)) {
		return -IPC_ERROR_BAD_RESPONSE;
	}

	return 0;
}
<% end %>
__EOF__
      ERB.new(template).result(binding)
    end

    private

    def include_guard_name
      'IPCC_GEN_' + @name.upcase.gsub(/[^A-Z0-9]/, '_') + '_H'
    end
  end

  class CodeGenerator
    def initialize(spec)
      @service = Service.new(spec)
    end

    def dump
      puts @service.to_c_header
      puts @service.to_c_source
    end
  end
end

ARGV.each do |arg|
  codegen = IPC::CodeGenerator.new(YAML.load(File.read(arg)))
  codegen.dump
end
